name: Terraform CI/CD (no backend file)

on:
  pull_request:
    branches: [ main ]
    paths: [ 'generated_modules/**' ]
  push:
    branches: [ main ]
    paths: [ 'generated_modules/**' ]
  workflow_dispatch: {}

permissions:
  contents: read
  pull-requests: write

env:
  AWS_REGION: ${{ vars.AWS_REGION }}
  TF_BACKEND_BUCKET: ${{ vars.TF_BACKEND_BUCKET }}
  TF_BACKEND_DDB_TABLE: ${{ vars.TF_BACKEND_DDB_TABLE }}

jobs:
  discover:
    runs-on: ubuntu-latest
    outputs:
      modules: ${{ steps.find.outputs.modules }}
    steps:
      - uses: actions/checkout@v4
      - id: find
        name: Find changed module folders
        run: |
          # For PRs, diff against base; for push, diff last commit.
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            git fetch origin ${{ github.base_ref }} --depth=1
            DIFF_RANGE="origin/${{ github.base_ref }}...HEAD"
          else
            DIFF_RANGE="${{ github.sha }}~1...${{ github.sha }}"
          fi

          # List unique top-level directories under generated_modules that changed
          CHANGED=$(git diff --name-only $DIFF_RANGE \
            | awk -F/ '/^generated_modules\//{print $1"/"$2}' | sort -u)

          # Fallback: if none detected, run nothing
          if [ -z "$CHANGED" ]; then
            echo '[]' > modules.json
          else
            printf '[\n' > modules.json
            FIRST=1
            for d in $CHANGED; do
              # Expand to full folder (generated_modules/<module_id>)
              echo " - $d"
              if [ $FIRST -eq 0 ]; then echo ',' >> modules.json; fi
              FIRST=0
              printf '  "%s"\n' "$d" >> modules.json
            done
            printf ']\n' >> modules.json
          fi
          echo "modules=$(cat modules.json)" >> $GITHUB_OUTPUT

  plan:
    if: github.event_name == 'pull_request'
    needs: discover
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        tfdir: ${{ fromJson(needs.discover.outputs.modules) }}
    steps:
      - uses: actions/checkout@v4
      - name: Export AWS creds (POC)
        run: |
          echo "AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}" >> $GITHUB_ENV
          echo "AWS_REGION=${{ env.AWS_REGION }}" >> $GITHUB_ENV
      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Terraform Init (S3 backend, no file)
        working-directory: ${{ matrix.tfdir }}
        run: |
          # Derive a unique state key from the folder path
          KEY="${{ matrix.tfdir }}/terraform.tfstate"
          terraform init -input=false \
            -backend-config="bucket=${TF_BACKEND_BUCKET}" \
            -backend-config="key=${KEY}" \
            -backend-config="region=${AWS_REGION}" \
            -backend-config="dynamodb_table=${TF_BACKEND_DDB_TABLE}" \
            -backend-config="encrypt=true"

      - name: Terraform Validate
        working-directory: ${{ matrix.tfdir }}
        run: |
          terraform fmt -check
          terraform validate

      - name: Terraform Plan
        id: plan
        working-directory: ${{ matrix.tfdir }}
        run: |
          if [ -f dev.tfvars ]; then
            terraform plan -input=false -no-color -var-file=dev.tfvars -out=tfplan
          else
            terraform plan -input=false -no-color -out=tfplan
          fi

      - name: Comment plan on PR
        uses: actions/github-script@v7
        with:
          script: |
            const { execSync } = require('node:child_process');
            const dir = '${{ matrix.tfdir }}';
            let out = '';
            try { out = execSync('terraform show -no-color tfplan', { cwd: dir }).toString(); }
            catch { out = 'Failed to render plan.'; }
            const body = `### Terraform Plan (${dir})\n\`\`\`\n${out.substring(0,60000)}\n\`\`\``;
            github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: context.issue.number, body });

  apply:
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    needs: discover
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        tfdir: ${{ fromJson(needs.discover.outputs.modules) }}
    steps:
      - uses: actions/checkout@v4
      - name: Export AWS creds (POC)
        run: |
          echo "AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}" >> $GITHUB_ENV
          echo "AWS_REGION=${{ env.AWS_REGION }}" >> $GITHUB_ENV
      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Terraform Init (S3 backend, no file)
        working-directory: ${{ matrix.tfdir }}
        run: |
          KEY="${{ matrix.tfdir }}/terraform.tfstate"
          terraform init -input=false \
            -backend-config="bucket=${TF_BACKEND_BUCKET}" \
            -backend-config="key=${KEY}" \
            -backend-config="region=${AWS_REGION}" \
            -backend-config="dynamodb_table=${TF_BACKEND_DDB_TABLE}" \
            -backend-config="encrypt=true"

      - name: Terraform Apply
        working-directory: ${{ matrix.tfdir }}
        run: |
          if [ -f dev.tfvars ]; then
            terraform apply -input=false -auto-approve -var-file=dev.tfvars
          else
            terraform apply -input=false -auto-approve
          fi
